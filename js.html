<script>
document.addEventListener('DOMContentLoaded', () => {

    // --- State Management ---
    const state = {
        mode: 'student', 
        currentDraftId: null,
        docStatus: 'draft',
        charsPerLine: 20, 
        correctionData: { baseText: "", items: [] }, 
        teacherPassword: null,
        draftsList: [],
        returnedDrafts: [],
        selectedStudentData: null,
        selectedIndex: -1,
        isDragging: false,
        dragStartIdx: null,
        dragEndIdx: null,
        checkedIds: new Set(),
        previousContent: "",
        // フィルタ状態
        teacherFilter: { keyword: '', dateStart: '', dateEnd: '', excludeCompleted: false }
    };

    const STORAGE_KEY = 'genko_pro_autosave_v2'; 
    const STORAGE_KEY_READ = 'genko_pro_read_receipts_v2'; 
    
    const dmp = new diff_match_patch();

    // --- Utils ---
    const debounce = (func, delay) => {
        let timeoutId;
        return (...args) => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => func(...args), delay);
        };
    };

    // --- UI Elements ---
    const ui = {
        views: { editor: document.getElementById('editor-view'), dashboard: document.getElementById('teacher-dashboard') },
        controls: { student: document.getElementById('student-controls') },
        title: document.getElementById('title'), 
        class: document.getElementById('class'), 
        name: document.getElementById('name'), 
        content: document.getElementById('content'),
        statusBadge: document.getElementById('doc-status-display'),
        grid: document.getElementById('genko-grid'),
        paperContainer: document.getElementById('paper-container'), 
        loading: document.getElementById('loading-overlay'),
        teacherListContainer: document.getElementById('teacher-list-container'),
        teacherList: document.getElementById('teacher-dashboard-list'),
        previewInfo: document.getElementById('preview-info'),
        btnRework: document.getElementById('btn-action-rework'),
        btnComplete: document.getElementById('btn-action-complete'),
        teacherGrid: document.getElementById('teacher-genko-grid'),
        printArea: document.getElementById('print-render-area'),
        notificationBtn: null,
        checkAll: document.getElementById('check-all'),
        btnSettings: document.getElementById('btn-settings') 
    };

    const setLoading = (show) => ui.loading.style.display = show ? 'flex' : 'none';

    // --- Robust Communication Wrapper ---
    async function runGAS(funcName, ...args) {
        let retryCount = 0;
        const maxRetries = 3;
        
        while (retryCount < maxRetries) {
            try {
                return await new Promise((resolve, reject) => {
                    google.script.run
                        .withSuccessHandler(resolve)
                        .withFailureHandler(reject)
                        [funcName](...args);
                });
            } catch (e) {
                console.warn(`Retry ${retryCount + 1}/${maxRetries} for ${funcName}`, e);
                retryCount++;
                if (retryCount >= maxRetries) {
                    Swal.fire({
                        icon: 'error',
                        title: '通信エラー',
                        html: 'サーバーとの通信に失敗しました。<br>しばらく待ってから再試行してください。',
                        confirmButtonText: '閉じる',
                        heightAuto: false
                    });
                    throw e;
                }
                await new Promise(r => setTimeout(r, 1000 * retryCount)); 
            }
        }
    }

    // --- Common Filter Logic ---
    const filterDataList = (list, criteria) => {
        return list.filter(item => {
            // キーワード (題名, 氏名, 本文)
            if (criteria.keyword) {
                const kw = criteria.keyword.toLowerCase();
                const text = ((item.title||'') + (item.name||'') + (item.content||'')).toLowerCase();
                if (!text.includes(kw)) return false;
            }
            // 日付範囲
            if (criteria.dateStart || criteria.dateEnd) {
                const itemDateStr = item.updatedAt.split(' ')[0]; // yyyy/MM/dd
                if (criteria.dateStart && itemDateStr < criteria.dateStart.replace(/-/g, '/')) return false;
                if (criteria.dateEnd && itemDateStr > criteria.dateEnd.replace(/-/g, '/')) return false;
            }
            // 完了済み除外
            if (criteria.excludeCompleted && item.status === 'completed') return false;

            return true;
        });
    };

    // --- Notification Button ---
    const teacherBtn = document.getElementById('btn-teacher-login');
    if (teacherBtn) {
        const navbarContainer = teacherBtn.parentNode;
        const notificationBtn = document.createElement('button');
        notificationBtn.className = 'btn btn-outline-warning position-relative me-2 d-none rounded-circle border-0';
        notificationBtn.innerHTML = `<i class="bi bi-bell-fill fs-5"></i><span class="position-absolute top-0 start-100 translate-middle p-2 bg-danger border border-light rounded-circle"><span class="visually-hidden">New alerts</span></span>`;
        notificationBtn.onclick = () => showReturnedListModal();
        navbarContainer.insertBefore(notificationBtn, teacherBtn);
        ui.notificationBtn = notificationBtn;
    }

    // --- Settings Modal (AI設定追加) ---
    const showSettings = async () => {
        let aiSettingHtml = '';
        if (state.mode === 'teacher') {
            const hasKey = await runGAS('hasGeminiKey');
            const keyStatus = hasKey ? '<span class="text-success fw-bold">設定済み</span>' : '<span class="text-danger fw-bold">未設定</span>';
            aiSettingHtml = `
                <hr>
                <div class="mb-3">
                    <label class="form-label fw-bold d-flex justify-content-between">
                        <span>Gemini APIキー (先生のみ)</span>
                        <small>${keyStatus}</small>
                    </label>
                    <input type="password" id="gemini-key" class="form-control" placeholder="AI添削用APIキーを入力">
                    <div class="form-text">設定すると自動添削機能が有効になります。</div>
                </div>
            `;
        }

        Swal.fire({
            title: '設定',
            html: `
                <div class="text-start p-3">
                    <label class="form-label fw-bold">用紙の文字数</label>
                    <div class="form-check mb-2">
                        <input class="form-check-input" type="radio" name="charSetting" id="char20" value="20" ${state.charsPerLine === 20 ? 'checked' : ''}>
                        <label class="form-check-label" for="char20">20文字 × 20行 (高学年)</label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="charSetting" id="char15" value="15" ${state.charsPerLine === 15 ? 'checked' : ''}>
                        <label class="form-check-label" for="char15">15文字 × 16行 (低学年)</label>
                    </div>
                    ${aiSettingHtml}
                </div>
            `,
            confirmButtonText: '保存して閉じる',
            showCancelButton: true,
            cancelButtonText: 'キャンセル',
            heightAuto: false, 
            preConfirm: () => {
                const charVal = parseInt(document.querySelector('input[name="charSetting"]:checked').value);
                const keyVal = document.getElementById('gemini-key') ? document.getElementById('gemini-key').value : null;
                return { charVal, keyVal };
            }
        }).then(async (result) => {
            if (result.isConfirmed) {
                const { charVal, keyVal } = result.value;
                
                // 文字数設定反映
                if (charVal !== state.charsPerLine) {
                    state.charsPerLine = charVal;
                    autoSave();
                    updateEditorUI();
                    if (state.mode === 'teacher') renderTeacherApp();
                }

                // APIキー保存
                if (keyVal) {
                    await runGAS('setGeminiApiKey', keyVal);
                    Swal.fire({ icon: 'success', title: '設定を保存しました', timer: 1500, showConfirmButton: false, heightAuto: false });
                } else if (charVal !== state.charsPerLine) {
                    // キー入力なしでも文字数が変わっていれば通知
                    Swal.fire({ icon: 'success', title: '変更しました', timer: 1000, showConfirmButton: false, heightAuto: false });
                }
            }
        });
    };

    if (ui.btnSettings) {
        ui.btnSettings.addEventListener('click', showSettings);
    }

    // --- 座標変換ロジック (Diff) ---
    const mapIndex = (index, diffs) => {
        let oldIndex = 0;
        let newIndex = 0;
        for (let i = 0; i < diffs.length; i++) {
            const type = diffs[i][0]; 
            const text = diffs[i][1];
            const len = text.length;
            
            if (type === 0) { 
                if (oldIndex + len > index) return newIndex + (index - oldIndex);
                oldIndex += len;
                newIndex += len;
            } else if (type === -1) { 
                if (oldIndex + len > index) return newIndex; 
                oldIndex += len;
            } else if (type === 1) { 
                newIndex += len;
            }
        }
        return newIndex;
    };

    const getAdjustedCorrections = (currentContent) => {
        const { baseText, items } = state.correctionData;
        if (!baseText) return items;

        const diffs = dmp.diff_main(baseText, currentContent);
        dmp.diff_cleanupSemantic(diffs);

        return items.map(item => {
            const newStart = mapIndex(item.start, diffs);
            const newEnd = mapIndex(item.end, diffs);
            return { ...item, start: newStart, end: Math.max(newStart, newEnd) };
        });
    };

    // --- Core Rendering Logic ---
    const generateHeaderLines = (title, className, name, chars) => {
        const lines = [];
        const titleParas = (title||'').split('\n');
        titleParas.forEach(p => {
            if(!p && lines.length===0) return;
            let line = Array(chars).fill({c:'', idx:null});
            let cursor = 2; 
            p.split('').forEach(char => {
                if(cursor >= chars) { lines.push(line); line = Array(chars).fill({c:'', idx:null}); cursor = 0; }
                const newLine = [...line]; newLine[cursor] = {c: char, idx: null}; line = newLine; cursor++;
            });
            lines.push(line);
        });
        if(lines.length===0 || (title && lines.length > 0)) lines.push(Array(chars).fill({c:'', idx:null}));
        const footerText = ((className||'') + ' ' + (name||'')).trim();
        if(footerText) {
            let line = Array(chars).fill({c:'', idx:null});
            let start = Math.max(0, chars - footerText.length - 1); 
            footerText.split('').forEach((char, i) => {
                if(start + i < chars) { const newLine = [...line]; newLine[start + i] = {c: char, idx: null}; line = newLine; }
            });
            lines.push(line); lines.push(Array(chars).fill({c:'', idx:null}));
        }
        return lines;
    };

    const parseBodyWithIndex = (text, chars) => {
        const lines = [];
        const noStart = ['、','。','」','』','）','っ','ゃ','ゅ','ょ','ッ','ャ','ュ','ョ','ー',',','.','」','』',']','}','>','ぁ','ぃ','ぅ','ぇ','ぉ','ァ','ィ','ゥ','ェ','ォ','ヮ','ヵ','ヶ','・','？','！','‼','⁇','々'];
        let charGlobalIndex = 0; 
        const paragraphs = (text||'').split('\n');
        paragraphs.forEach(p => {
            if (p === '') { lines.push(Array(chars).fill({c:'', idx:null})); charGlobalIndex += 1; return; }
            let line = [];
            const pChars = p.split('');
            let i = 0;
            while (i < pChars.length) {
                const char = pChars[i];
                let cellData = { c: char, idx: charGlobalIndex + i };
                line.push(cellData);
                i++;
                if (line.length >= chars) {
                    if (i < pChars.length && noStart.includes(pChars[i])) {
                        line.push({ c: pChars[i], idx: charGlobalIndex + i }); i++;
                    }
                    lines.push(line); line = [];
                }
            }
            if (line.length > 0) { while(line.length < chars) line.push({c:'', idx:null}); lines.push(line); }
            charGlobalIndex += pChars.length + 1;
        });
        return lines;
    };

    const renderToGrid = (targetGrid, title, className, name, content, corrections, isTeacherView = false) => {
        const chars = state.charsPerLine;
        const headerLines = generateHeaderLines(title, className, name, chars);
        const bodyLines = parseBodyWithIndex(content, chars);
        const allLines = [...headerLines, ...bodyLines];

        targetGrid.innerHTML = '';
        const renderLen = Math.max(allLines.length, 10);

        for(let i=0; i<renderLen; i++) {
            const lineData = allLines[i] || Array(chars).fill({c:'', idx:null});
            const lineDiv = document.createElement('div');
            lineDiv.className = 'genko-line';
            lineDiv.style.flexShrink = '0'; 

            for(let j=0; j<chars; j++) {
                const cellData = lineData[j] || {c:'', idx:null};
                const cell = document.createElement('div');
                cell.className = 'genko-cell';
                
                cell.style.width = chars===20 ? '2.8rem' : '3.2rem';
                cell.style.height = chars===20 ? '2.8rem' : '3.2rem';
                cell.style.fontSize = chars===20 ? '1.6rem' : '1.8rem';
                cell.textContent = cellData.c;

                if (j === chars - 1 && lineData.length > chars) {
                    const hangingPart = lineData.slice(chars);
                    const hDiv = document.createElement('div');
                    hDiv.className = 'hanging-char';
                    hDiv.textContent = hangingPart.map(d => d.c).join('');
                    cell.appendChild(hDiv);
                }

                if (cellData.idx !== null && corrections && corrections.length > 0) {
                    const cor = corrections.find(c => cellData.idx >= c.start && cellData.idx < c.end);
                    if (cor) {
                        const isResolved = cor.status === 'resolved';
                        if (isTeacherView || !isResolved) {
                            cell.classList.add('corrected');
                            if (isResolved && isTeacherView) {
                                cell.style.setProperty('--teacher-color', '#198754'); 
                            } else {
                                cell.style.removeProperty('--teacher-color');
                            }
                            cell.onclick = (e) => {
                                if(!state.isDragging) {
                                    e.stopPropagation(); 
                                    showCorrectionPopup(cor, isTeacherView);
                                }
                            };
                        }
                    }
                }
                
                if (isTeacherView && cellData.idx !== null) {
                    cell.dataset.idx = cellData.idx;
                }

                lineDiv.appendChild(cell);
            }
            targetGrid.appendChild(lineDiv);
        }
    };
    
    // 添削ポップアップ
    const showCorrectionPopup = (cor, isTeacherView) => {
        if (isTeacherView) {
            const original = cor.originalText || '(不明)';
            let statusHtml = cor.status === 'resolved' 
                ? '<span class="badge bg-success mb-2">修正完了</span>' 
                : '<span class="badge bg-danger mb-2">未修正</span>';

            Swal.fire({
                title: '添削詳細',
                html: `
                    ${statusHtml}
                    <div class="text-start">
                        <label class="fw-bold small text-muted">コメント:</label>
                        <div class="alert alert-info py-2">${cor.comment}</div>
                        <label class="fw-bold small text-muted">指摘時の内容:</label>
                        <div class="p-2 bg-light border rounded mb-2 text-decoration-line-through text-muted">${original}</div>
                    </div>
                `,
                confirmButtonText: '閉じる',
                heightAuto: false
            });
        } else {
            Swal.fire({
                title: '先生からのコメント',
                html: `<div class="fs-5 mb-3">${cor.comment}</div>`,
                icon: 'info',
                showCancelButton: true,
                confirmButtonText: '修正を完了する (赤線を消す)',
                cancelButtonText: '閉じる',
                confirmButtonColor: '#198754',
                heightAuto: false
            }).then((result) => {
                if (result.isConfirmed) {
                    resolveCorrection(cor);
                }
            });
        }
    };
    
    const resolveCorrection = (targetCor) => {
        const item = state.correctionData.items.find(c => c.id === targetCor.id);
        if (item) {
            item.status = 'resolved';
            renderStudentApp();
            autoSave(); 
            saveStatusToServer();
            
            const Toast = Swal.mixin({ toast: true, position: 'top-end', showConfirmButton: false, timer: 2000 });
            Toast.fire({ icon: 'success', title: '修正完了としてマークしました' });
        }
    };

    const saveStatusToServer = async () => {
        const data = {
            id: state.currentDraftId,
            title: ui.title.value,
            class: ui.class.value,
            name: ui.name.value,
            content: ui.content.value,
            correction: JSON.stringify(state.correctionData),
            status: state.docStatus
        };
        try { await runGAS('saveOrSubmitDraft', data, false); } catch(e){}
    };

    const renderStudentApp = () => {
        const activeCorrections = getAdjustedCorrections(ui.content.value);
        renderToGrid(ui.grid, ui.title.value, ui.class.value, ui.name.value, ui.content.value, activeCorrections, false);
        requestAnimationFrame(() => {
            setTimeout(() => {
                const sheet = ui.paperContainer.querySelector('.paper-sheet');
                fitPaperToScreen(ui.paperContainer, sheet);
            }, 100);
        });
    };

    const renderTeacherApp = () => {
        const d = state.selectedStudentData || { title: '', class: '', name: '', content: '' };
        
        let cors = [];
        if (state.correctionData && state.correctionData.items) {
             cors = getAdjustedCorrections(d.content);
        }
        
        renderToGrid(ui.teacherGrid, d.title, d.class, d.name, d.content, cors, true);
        
        const container = document.getElementById('teacher-preview-container');
        const sheet = container.querySelector('.paper-sheet');
        requestAnimationFrame(() => {
            setTimeout(() => {
                 fitPaperToScreen(container, sheet);
            }, 100);
        });
    };
    
    const fitPaperToScreen = (container, sheet) => {
        if(!sheet || !container) return;
        
        const scaler = sheet.parentElement; 
        const wrapper = scaler.parentElement; 
        
        scaler.style.transform = 'scale(1)';
        wrapper.style.width = 'auto'; 
        wrapper.style.height = 'auto';
        
        const containerRect = container.getBoundingClientRect();
        const availableH = containerRect.height - 40; 
        
        if (availableH < 100) return;

        const sheetW = sheet.offsetWidth;
        const sheetH = sheet.offsetHeight;
        
        if(sheetH === 0 || availableH <= 0) return;
        
        let scale = availableH / sheetH;
        if (scale > 1) scale = 1;
        if (scale < 0.2) scale = 0.2;

        scaler.style.transform = `scale(${scale})`;
        wrapper.style.width = `${sheetW * scale}px`;
        wrapper.style.height = `${sheetH * scale}px`;
        
        container.style.overflowX = 'auto';
        container.style.overflowY = 'hidden'; 
    };

    window.addEventListener('resize', () => {
        if(state.mode === 'student') {
             const sheet = ui.paperContainer.querySelector('.paper-sheet');
             fitPaperToScreen(ui.paperContainer, sheet);
        } else {
             const container = document.getElementById('teacher-preview-container');
             const sheet = container ? container.querySelector('.paper-sheet') : null;
             fitPaperToScreen(container, sheet);
        }
    });
    
    window.addEventListener('load', () => {
        if(state.mode === 'student') {
             const sheet = ui.paperContainer.querySelector('.paper-sheet');
             fitPaperToScreen(ui.paperContainer, sheet);
        }
    });

    // --- Student Logic ---
    const autoSave = () => {
        if(state.mode !== 'student') return;
        localStorage.setItem(STORAGE_KEY, JSON.stringify({
            id: state.currentDraftId, title: ui.title.value, class: ui.class.value, name: ui.name.value,
            content: ui.content.value, status: state.docStatus, 
            charsPerLine: state.charsPerLine, 
            timestamp: new Date().getTime()
        }));
    };

    const restoreFromAutoSave = () => {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
            try {
                const data = JSON.parse(saved);
                if (data.title || data.content) {
                    state.currentDraftId = data.id || null;
                    state.docStatus = data.status || 'draft';
                    if (data.charsPerLine) state.charsPerLine = data.charsPerLine; 
                    ui.title.value = data.title||''; ui.class.value = data.class||''; ui.name.value = data.name||''; ui.content.value = data.content||'';
                    state.previousContent = data.content || ''; 
                    updateEditorUI();
                    const Toast = Swal.mixin({ toast: true, position: 'top-end', showConfirmButton: false, timer: 2000 });
                    Toast.fire({ icon: 'info', title: '前回の続きを読み込みました' });
                }
            } catch (e) {}
        }
    };

    const checkReturnedAssignments = async () => {
        try {
            const res = await runGAS('getDraftList', 'student');
            if(res.status === 'success') {
                const list = res.data;
                const allReturned = list.filter(d => ['rework','completed','returned'].includes(d.status));
                const readReceipts = JSON.parse(localStorage.getItem(STORAGE_KEY_READ) || '{}');
                const unread = allReturned.filter(d => {
                    const lastReadTime = readReceipts[d.id];
                    return lastReadTime !== d.updatedAt;
                });
                state.returnedDrafts = allReturned;

                if(unread.length > 0 && ui.notificationBtn) {
                    ui.notificationBtn.classList.remove('d-none');
                    const Toast = Swal.mixin({ toast: true, position: 'top-end', showConfirmButton: false, timer: 4000 });
                    Toast.fire({ icon: 'info', title: `新しい返却が ${unread.length} 件あります` });
                } else if (ui.notificationBtn) {
                    ui.notificationBtn.classList.add('d-none');
                }
            }
        } catch(e) {}
    };

    const markAsRead = (item) => {
        const readReceipts = JSON.parse(localStorage.getItem(STORAGE_KEY_READ) || '{}');
        readReceipts[item.id] = item.updatedAt;
        localStorage.setItem(STORAGE_KEY_READ, JSON.stringify(readReceipts));
        checkReturnedAssignments();
    };

    const showReturnedListModal = () => {
        if(state.returnedDrafts.length === 0) return;
        const readReceipts = JSON.parse(localStorage.getItem(STORAGE_KEY_READ) || '{}');
        const listHtml = state.returnedDrafts.map(item => {
            const isUnread = readReceipts[item.id] !== item.updatedAt;
            const badgeHtml = isUnread ? '<span class="badge bg-danger ms-2">New</span>' : '';
            const bgClass = isUnread ? 'bg-white' : 'bg-light text-muted';
            let statusLabel = '';
            if(item.status === 'rework') statusLabel = '【再提出】';
            else if(item.status === 'completed') statusLabel = '【完了】';
            else statusLabel = '【返却済】';

            return `
            <div class="d-flex justify-content-between align-items-center p-3 border-bottom text-start ${bgClass}">
                <div>
                    <div class="fw-bold text-danger">${statusLabel} ${item.title || '(無題)'} ${badgeHtml}</div>
                    <div class="small text-muted">${item.updatedAt}</div>
                </div>
                <button class="btn btn-sm btn-outline-primary open-returned-btn rounded-pill px-3" data-id="${item.id}">確認</button>
            </div>`;
        }).join('');

        Swal.fire({
            title: '先生から返却された作文',
            html: `<div style="max-height: 300px; overflow-y: auto;">${listHtml}</div>`,
            showCloseButton: true, showConfirmButton: false,
            width: '600px',
            heightAuto: false, 
            didOpen: () => {
                const container = Swal.getHtmlContainer();
                container.querySelectorAll('.open-returned-btn').forEach(btn => {
                    btn.addEventListener('click', () => { confirmAndOpenReturned(btn.dataset.id); });
                });
            }
        });
    };

    const confirmAndOpenReturned = (id) => {
        Swal.close();
        const target = state.returnedDrafts.find(d => d.id === id);
        if (target) markAsRead(target);

        if (state.currentDraftId !== id && (ui.content.value.trim() !== '' || ui.title.value.trim() !== '')) {
            Swal.fire({
                title: '作業中の内容があります',
                text: '返却された作文を開くと、現在入力中の内容は消えてしまいます。開きますか？',
                icon: 'warning', 
                showCancelButton: true, 
                confirmButtonText: '開く（今の内容は破棄）', 
                cancelButtonText: 'キャンセル',
                confirmButtonColor: '#d33',
                cancelButtonColor: '#3085d6',
                heightAuto: false 
            }).then((result) => { if (result.isConfirmed) loadStudentDraft(id); });
        } else {
            loadStudentDraft(id);
        }
    };

    // --- 楽観的保存: 生徒の保存/提出 ---
    const handleSave = (isSubmit) => {
        if(!ui.content.value) return Swal.fire({ title: 'エラー', text: '本文がありません', icon: 'warning', heightAuto: false });
        
        if (!state.currentDraftId) {
            handleSaveNew(isSubmit);
            return;
        }

        if (isSubmit) {
            Swal.fire({
                title: '先生に提出しますか？',
                text: "提出すると、先生が確認するまで変更できなくなります。",
                icon: 'question',
                showCancelButton: true,
                confirmButtonText: 'はい、提出します',
                cancelButtonText: 'いいえ',
                confirmButtonColor: '#1a73e8',
                heightAuto: false
            }).then((result) => {
                if(result.isConfirmed) executeOptimisticSave(isSubmit);
            });
        } else {
            executeOptimisticSave(false);
        }
    };

    const handleSaveNew = async (isSubmit) => {
        if (isSubmit) {
            const res = await Swal.fire({
                title: '先生に提出しますか？',
                text: "提出すると、先生が確認するまで変更できなくなります。",
                icon: 'question',
                showCancelButton: true,
                confirmButtonText: 'はい、提出します',
                cancelButtonText: 'いいえ',
                confirmButtonColor: '#1a73e8',
                heightAuto: false
            });
            if (!res.isConfirmed) return;
        }

        setLoading(true);
        const data = { id: null, title: ui.title.value, class: ui.class.value, name: ui.name.value, content: ui.content.value };
        
        try {
            const res = await runGAS('saveOrSubmitDraft', data, isSubmit);
            setLoading(false);
            if(res.status === 'success') {
                state.currentDraftId = res.id; state.docStatus = res.docStatus;
                updateEditorUI(); autoSave();
                Swal.fire({ icon: 'success', title: '完了', text: res.message, heightAuto: false });
            } else Swal.fire({ icon: 'error', title: 'エラー', text: res.message, heightAuto: false });
        } catch(e) { setLoading(false); }
    };

    const executeOptimisticSave = (isSubmit) => {
        const prevStatus = state.docStatus;
        if (isSubmit) state.docStatus = 'submitted';
        updateEditorUI();
        autoSave();

        const msg = isSubmit ? '提出しました！' : '保存しました';
        const Toast = Swal.mixin({ toast: true, position: 'top-end', showConfirmButton: false, timer: 2000 });
        Toast.fire({ icon: 'success', title: msg });

        const data = { id: state.currentDraftId, title: ui.title.value, class: ui.class.value, name: ui.name.value, content: ui.content.value };
        runGAS('saveOrSubmitDraft', data, isSubmit).then(res => {
            if(res.status !== 'success') {
                state.docStatus = prevStatus;
                updateEditorUI();
                Swal.fire({ title: '保存エラー', text: 'サーバーへの保存に失敗しました: ' + res.message, icon: 'error', heightAuto: false });
            }
        }).catch(e => {
             state.docStatus = prevStatus;
             updateEditorUI();
             Swal.fire({ title: '通信エラー', text: '接続を確認してください', icon: 'error', heightAuto: false });
        });
    };

    const updateEditorUI = () => {
        const s = state.docStatus;
        const badge = ui.statusBadge;
        badge.className = 'badge rounded-pill px-3';
        if(s==='submitted') { badge.classList.add('bg-primary'); badge.innerText = '提出済'; }
        else if(s==='rework') { badge.classList.add('bg-warning','text-dark'); badge.innerText = '再提出'; }
        else if(s==='completed') { badge.classList.add('bg-success'); badge.innerText = '完了'; }
        else { badge.classList.add('bg-secondary'); badge.innerText = '下書き'; }

        const isLocked = (state.mode === 'teacher') || (s === 'submitted' || s === 'completed');
        ui.content.readOnly = ui.title.readOnly = ui.class.readOnly = ui.name.readOnly = isLocked;
        
        if (state.mode === 'student') {
            ui.controls.student.classList.remove('d-none');
            document.getElementById('btn-save').disabled = isLocked;
            document.getElementById('btn-submit').disabled = isLocked;
        } else {
            ui.controls.student.classList.add('d-none');
        }
        renderStudentApp();
    };

    document.getElementById('btn-save').addEventListener('click', () => handleSave(false));
    document.getElementById('btn-submit').addEventListener('click', () => handleSave(true));
    document.getElementById('btn-new').addEventListener('click', async () => {
        if (state.docStatus==='draft' && ui.content.value) {
            const r = await Swal.fire({title:'確認', text:'現在の内容は消去されます。よろしいですか？', showCancelButton:true, confirmButtonText:'新規作成', cancelButtonText:'キャンセル', heightAuto: false});
            if (!r.isConfirmed) return;
        }
        state.currentDraftId = null; state.docStatus = 'draft'; 
        state.correctionData = { baseText: "", items: [] }; 
        ui.title.value=''; ui.class.value=''; ui.name.value=''; ui.content.value='';
        updateEditorUI(); autoSave();
    });

    // 児童用: 読み込みボタン (検索機能付き)
    document.getElementById('btn-load').addEventListener('click', async () => {
        setLoading(true);
        try {
            const res = await runGAS('getDraftList', 'student');
            setLoading(false);
            if(res.status==='success') {
                const allData = res.data;
                if(allData.length===0) return Swal.fire({ title: 'なし', text: '保存されたデータがありません', icon: 'info', heightAuto: false });
                
                // フィルタリング機能付きモーダル
                Swal.fire({ 
                    title: '保存した作文を開く',
                    html: `
                        <div class="mb-3 text-start">
                            <input type="text" id="load-search" class="form-control mb-2" placeholder="キーワード検索">
                            <div class="input-group input-group-sm">
                                <span class="input-group-text">期間</span>
                                <input type="date" id="load-date-start" class="form-control">
                                <span class="input-group-text">~</span>
                                <input type="date" id="load-date-end" class="form-control">
                            </div>
                        </div>
                        <div id="load-list-container" style="max-height:300px;overflow:auto;text-align:left;"></div>
                    `,
                    showConfirmButton:false, 
                    showCloseButton: true,
                    heightAuto: false, 
                    didOpen:()=>{
                        const container = document.getElementById('load-list-container');
                        const searchInput = document.getElementById('load-search');
                        const dateStart = document.getElementById('load-date-start');
                        const dateEnd = document.getElementById('load-date-end');

                        const renderList = () => {
                            const criteria = {
                                keyword: searchInput.value,
                                dateStart: dateStart.value,
                                dateEnd: dateEnd.value
                            };
                            const filtered = filterDataList(allData, criteria);
                            
                            if (filtered.length === 0) {
                                container.innerHTML = '<div class="text-muted p-2">一致するデータがありません</div>';
                                return;
                            }

                            container.innerHTML = filtered.map(i => `
                                <div class="d-flex justify-content-between align-items-center p-2 border-bottom">
                                    <div class="text-start" style="min-width:0;">
                                        <div class="fw-bold text-truncate">${i.title || '(無題)'}</div>
                                        <small class="text-muted">${i.updatedAt}</small>
                                    </div>
                                    <button class="btn btn-sm btn-outline-success l-btn rounded-pill px-3 ms-2 flex-shrink-0" data-id="${i.id}">開く</button>
                                </div>`).join('');
                            
                            container.querySelectorAll('.l-btn').forEach(b => b.onclick = () => { Swal.close(); loadStudentDraft(b.dataset.id); });
                        };

                        searchInput.addEventListener('input', renderList);
                        dateStart.addEventListener('change', renderList);
                        dateEnd.addEventListener('change', renderList);
                        
                        renderList(); // 初回描画
                    }
                });
            }
        } catch(e) { setLoading(false); }
    });

    const loadStudentDraft = async (id) => {
        setLoading(true);
        try {
            const res = await runGAS('loadDraft', id);
            setLoading(false);
            if(res.status === 'success') {
                const d = res.data;
                state.currentDraftId = d.id; state.docStatus = d.status || 'draft';
                let cors = [];
                if (d.correction) {
                    if (typeof d.correction === 'string') {
                        try { cors = JSON.parse(d.correction); } catch(e) {}
                    } else {
                        cors = d.correction;
                    }
                }
                if (Array.isArray(cors)) {
                    state.correctionData = { baseText: d.content || "", items: cors };
                } else if (cors && cors.items) {
                    state.correctionData = cors;
                } else {
                    state.correctionData = { baseText: d.content || "", items: [] };
                }

                ui.title.value=d.title; ui.class.value=d.class; ui.name.value=d.name; ui.content.value=d.content;
                updateEditorUI(); autoSave();
                if((d.status==='rework'||d.status==='completed') && d.teacherCmt) Swal.fire({ title: '先生コメント', text: d.teacherCmt, icon: 'info', heightAuto: false });
            } else Swal.fire({ title: 'エラー', text: res.message, icon: 'error', heightAuto: false });
        } catch(e) { setLoading(false); }
    };
    
    [ui.title, ui.class, ui.name].forEach(el => el.addEventListener('input', () => { 
        renderStudentApp();
        autoSave(); 
    }));
    
    ui.content.addEventListener('input', () => {
        renderStudentApp();
        autoSave();
    });

    // --- Teacher Logic ---
    // 教師用フィルターUIの初期化
    const initTeacherFilterUI = () => {
        // すでに存在すればスキップ
        if (document.getElementById('teacher-filter-ui')) return;

        const filterDiv = document.createElement('div');
        filterDiv.id = 'teacher-filter-ui';
        filterDiv.className = 'p-2 bg-white border-bottom small';
        filterDiv.innerHTML = `
            <input type="text" id="t-filter-search" class="form-control form-control-sm mb-2" placeholder="キーワード検索 (題名・氏名・本文)">
            <div class="d-flex gap-1 mb-2">
                <input type="date" id="t-filter-start" class="form-control form-control-sm">
                <span class="align-self-center">~</span>
                <input type="date" id="t-filter-end" class="form-control form-control-sm">
            </div>
            <div class="form-check">
                <input class="form-check-input" type="checkbox" id="t-filter-exclude">
                <label class="form-check-label" for="t-filter-exclude">完了済みを表示しない</label>
            </div>
        `;
        
        // リストコンテナの前に挿入
        ui.teacherListContainer.parentNode.insertBefore(filterDiv, ui.teacherListContainer);

        // AIボタンをプレビュー上部に追加
        if (!document.getElementById('btn-ai-correction')) {
            const btnGroup = document.getElementById('teacher-action-buttons');
            const aiBtn = document.createElement('button');
            aiBtn.id = 'btn-ai-correction';
            aiBtn.className = 'btn btn-sm btn-warning text-dark fw-bold rounded-pill px-3 ms-1 disabled';
            aiBtn.innerHTML = '<i class="bi bi-stars"></i> AI添削';
            aiBtn.onclick = runAiCorrection;
            // 先頭に挿入
            btnGroup.insertBefore(aiBtn, btnGroup.firstChild);
        }

        // イベントリスナー
        const search = document.getElementById('t-filter-search');
        const searchBtn = document.getElementById('t-filter-btn');
        const start = document.getElementById('t-filter-start');
        const end = document.getElementById('t-filter-end');
        const exclude = document.getElementById('t-filter-exclude');
        const statusText = document.getElementById('t-status-text');
        const updateFilter = () => {
            state.teacherFilter = {
                keyword: search.value,
                dateStart: start.value,
                dateEnd: end.value,
                excludeCompleted: exclude.checked
            };
            renderTeacherList();
        };

        search.addEventListener('input', updateFilter);
        start.addEventListener('change', updateFilter);
        end.addEventListener('change', updateFilter);
        exclude.addEventListener('change', updateFilter);
    };

    // AI添削実行関数
    const runAiCorrection = async () => {
        const d = state.selectedStudentData;
        if (!d) return;

        // 確認
        const confirm = await Swal.fire({
            title: 'AI自動添削を実行しますか？',
            text: '現在の内容をAIが分析し、アドバイスを赤線で追記します。',
            icon: 'question',
            showCancelButton: true,
            confirmButtonText: '実行する',
            cancelButtonText: 'キャンセル',
            heightAuto: false
        });
        if (!confirm.isConfirmed) return;

        // ローディング表示（AIは時間かかるので全体スピナー）
        setLoading(true);
        const infoEl = document.getElementById('preview-info');
        const originalInfo = infoEl.innerHTML;
        infoEl.innerHTML = '<span class="text-warning"><i class="spinner-border spinner-border-sm"></i> AI分析中...</span>';

        try {
            const resultItems = await runGAS('analyzeEssayWithGemini', d.title, d.class, d.content);
            setLoading(false);
            
            if (!resultItems || resultItems.length === 0) {
                Swal.fire({ icon: 'info', title: '修正提案はありませんでした', text: 'AIは修正の必要性を検出しませんでした。', heightAuto: false });
                return;
            }

            // 結果を反映
            // 既存データがあればマージ、なければ新規作成
            // baseTextを現在のcontentに更新し、新しいitemsを追加する
            
            // 既存のitemsを現在座標系に変換
            const currentContent = d.content;
            let currentItems = getAdjustedCorrections(currentContent);
            
            let addedCount = 0;
            resultItems.forEach(aiItem => {
                // 本文内を検索して位置を特定
                // 最初に見つかった場所を採用する（簡易実装）
                const idx = currentContent.indexOf(aiItem.quote);
                if (idx !== -1) {
                    const newCorrection = {
                        id: crypto.randomUUID(),
                        start: idx,
                        end: idx + aiItem.quote.length,
                        comment: '【AI】' + aiItem.comment,
                        originalText: aiItem.quote,
                        status: 'active'
                    };
                    currentItems.push(newCorrection);
                    addedCount++;
                }
            });

            if (addedCount === 0) {
                Swal.fire({ icon: 'warning', title: '対象箇所が見つかりませんでした', text: 'AIが指摘した文字列が本文内で見つかりませんでした。', heightAuto: false });
            } else {
                // データ更新と保存
                state.correctionData = {
                    baseText: currentContent,
                    items: currentItems
                };
                
                // 楽観的保存処理を流用
                document.getElementById('btn-save-correction').click(); // ダミー発火はできないのでロジック呼び出し
                // サーバー保存手動呼び出し
                renderTeacherApp();
                const data = {
                    id: d.id, title: d.title, class: d.class, name: d.name, content: d.content,
                    correction: JSON.stringify(state.correctionData), status: d.status
                };
                runGAS('saveOrSubmitDraft', data, true); // バックグラウンド保存
                
                Swal.fire({ icon: 'success', title: `${addedCount}件のアドバイスを追加しました`, heightAuto: false });
            }

        } catch (e) {
            setLoading(false);
            Swal.fire({ title: 'AIエラー', text: e.message, icon: 'error', heightAuto: false });
        } finally {
            infoEl.innerHTML = originalInfo;
        }
    };

    document.getElementById('btn-teacher-login').addEventListener('click', async () => {
        const { value: pass } = await Swal.fire({ title: '先生用ログイン', input: 'password', inputPlaceholder: 'パスワード', showCancelButton: true, heightAuto: false });
        if (pass) {
            setLoading(true);
            try {
                const res = await runGAS('getDraftList', 'teacher', pass);
                setLoading(false);
                if(res.status === 'success') {
                    state.mode = 'teacher'; state.teacherPassword = pass;
                    state.draftsList = res.data; 
                    document.body.classList.add('teacher-mode');
                    if(ui.notificationBtn) ui.notificationBtn.classList.add('d-none');
                    ui.views.editor.classList.add('d-none');
                    ui.views.dashboard.classList.remove('d-none');
                    
                    initTeacherFilterUI(); // フィルタUI初期化
                    renderTeacherList();
                    renderTeacherApp(); 
                } else Swal.fire({ title: '失敗', text: res.message, icon: 'error', heightAuto: false });
            } catch(e) { setLoading(false); }
        }
    });

    document.getElementById('btn-teacher-logout').addEventListener('click', () => {
        state.mode = 'student'; state.teacherPassword = null;
        state.draftsList = []; state.currentDraftId = null; state.docStatus = 'draft'; 
        state.correctionData = { baseText: "", items: [] };
        state.selectedStudentData = null; state.selectedIndex = -1;
        state.checkedIds = new Set();
        if (ui.checkAll) ui.checkAll.checked = false;

        ui.teacherGrid.innerHTML = '';
        ui.title.value = ''; ui.class.value = ''; ui.name.value = ''; ui.content.value = '';
        document.body.classList.remove('teacher-mode');
        ui.views.dashboard.classList.add('d-none');
        ui.views.editor.classList.remove('d-none');
        restoreFromAutoSave();
        checkReturnedAssignments();
        updateEditorUI();
    });

    const renderTeacherList = () => {
        // フィルタリング適用
        const filteredList = filterDataList(state.draftsList, state.teacherFilter);
        
        ui.teacherList.innerHTML = filteredList.map((item) => {
            // 元リスト内でのインデックスを探す（選択処理用）
            const originalIdx = state.draftsList.findIndex(d => d.id === item.id);
            
            let badge = '';
            if(item.status==='submitted') badge = '<span class="badge bg-primary">未</span>';
            else if(item.status==='rework') badge = '<span class="badge bg-warning text-dark">再</span>';
            else if(item.status==='completed') badge = '<span class="badge bg-success">完</span>';
            
            const activeClass = (originalIdx === state.selectedIndex) ? 'active' : '';
            const isChecked = state.checkedIds.has(item.id) ? 'checked' : '';
            
            return `
            <div class="list-group-item list-group-item-action ${activeClass} d-flex align-items-start gap-2 p-3" onclick="selectTeacherListItem(${originalIdx})">
                <div class="pt-1" onclick="event.stopPropagation()">
                    <input type="checkbox" class="form-check-input select-item border-secondary" value="${item.id}" ${isChecked} onchange="toggleCheck('${item.id}')">
                </div>
                <div class="flex-grow-1 overflow-hidden">
                    <div class="d-flex w-100 justify-content-between align-items-center">
                        <h6 class="mb-0 text-truncate fw-bold" style="max-width: 120px;">${item.name}</h6>
                        <small>${badge}</small>
                    </div>
                    <div class="d-flex justify-content-between align-items-center mt-1">
                        <p class="mb-0 text-truncate small text-muted" style="max-width: 140px;">${item.title}</p>
                        <small class="text-muted" style="font-size:0.65em">${item.updatedAt.split(' ')[1] || item.updatedAt}</small>
                    </div>
                </div>
            </div>`;
        }).join('');
        
        // 全選択チェックボックスの状態更新
        if (ui.checkAll) {
            const visibleIds = filteredList.map(d => d.id);
            const allChecked = visibleIds.length > 0 && visibleIds.every(id => state.checkedIds.has(id));
            const someChecked = visibleIds.some(id => state.checkedIds.has(id));
            
            ui.checkAll.checked = allChecked;
            ui.checkAll.indeterminate = !allChecked && someChecked;
            
            // 全選択イベントの更新（表示されているものだけを対象にする）
            ui.checkAll.onclick = (e) => {
                const isChecked = e.target.checked;
                visibleIds.forEach(id => {
                    if (isChecked) state.checkedIds.add(id);
                    else state.checkedIds.delete(id);
                });
                renderTeacherList();
            };
        }
    };

    window.selectTeacherListItem = (idx) => {
        state.selectedIndex = idx;
        state.selectedStudentData = state.draftsList[idx];
        renderTeacherList(); 
        const d = state.selectedStudentData;
        ui.previewInfo.innerHTML = `${d.class} ${d.name} 「${d.title}」`;
        
        ui.btnRework.classList.remove('disabled');
        // AIボタン制御: 完了済みでなければ有効化
        const aiBtn = document.getElementById('btn-ai-correction');
        
        if (d.status === 'completed') {
            ui.btnComplete.classList.add('disabled');
            ui.btnComplete.innerHTML = '<i class="bi bi-check-circle-fill"></i> 返却済';
            if(aiBtn) aiBtn.classList.add('disabled');
        } else {
            ui.btnComplete.classList.remove('disabled');
            ui.btnComplete.innerHTML = '完了(合格)にして次へ &gt;';
            if(aiBtn) aiBtn.classList.remove('disabled');
        }

        let cors = [];
        if (d.correction) {
            if (typeof d.correction === 'string') {
                try { cors = JSON.parse(d.correction); } catch(e) {}
            } else {
                cors = d.correction;
            }
        }
        if (Array.isArray(cors)) {
            state.correctionData = { baseText: d.content || "", items: cors };
        } else if (cors && cors.items) {
            state.correctionData = cors;
        } else {
            state.correctionData = { baseText: d.content || "", items: [] };
        }

        renderTeacherApp();
    };

    window.toggleCheck = (id) => {
        if (state.checkedIds.has(id)) state.checkedIds.delete(id);
        else state.checkedIds.add(id);
        renderTeacherList(); 
    };

    // --- Correction Logic (Drag) ---
    const clearSelectionHighlight = () => {
        const cells = ui.teacherGrid.querySelectorAll('.genko-cell.selecting');
        cells.forEach(cell => cell.classList.remove('selecting'));
        state.isDragging = false;
        state.dragStartIdx = null; state.dragEndIdx = null;
    };

    document.getElementById('correctionModal').addEventListener('hidden.bs.modal', () => { clearSelectionHighlight(); });

    ui.teacherGrid.addEventListener('mousedown', (e) => {
        const cell = e.target.closest('.genko-cell');
        if(!cell || !cell.dataset.idx) return;
        state.isDragging = true;
        state.dragStartIdx = parseInt(cell.dataset.idx);
        state.dragEndIdx = state.dragStartIdx;
        highlightSelection();
    });

    ui.teacherGrid.addEventListener('mousemove', (e) => {
        if(!state.isDragging) return;
        const cell = e.target.closest('.genko-cell');
        if(!cell || !cell.dataset.idx) return;
        state.dragEndIdx = parseInt(cell.dataset.idx);
        highlightSelection();
    });

    ui.teacherGrid.addEventListener('mouseup', (e) => {
        if(!state.isDragging) return;
        state.isDragging = false;
        showCorrectionModal();
    });
    
    const highlightSelection = () => {
        const start = Math.min(state.dragStartIdx, state.dragEndIdx);
        const end = Math.max(state.dragStartIdx, state.dragEndIdx);
        const cells = ui.teacherGrid.querySelectorAll('.genko-cell[data-idx]');
        cells.forEach(cell => {
            const idx = parseInt(cell.dataset.idx);
            if (idx >= start && idx <= end) cell.classList.add('selecting');
            else cell.classList.remove('selecting');
        });
    };
    
    const showCorrectionModal = () => {
        const modalEl = document.getElementById('correctionModal');
        let modal = bootstrap.Modal.getInstance(modalEl);
        if (!modal) modal = new bootstrap.Modal(modalEl);
        document.getElementById('correction-text').value = ''; 
        modal.show();
    };

    // 楽観的保存: 添削保存
    document.getElementById('btn-save-correction').addEventListener('click', () => {
        const text = document.getElementById('correction-text').value;
        if (!text) return;
        
        const d = state.selectedStudentData;
        if(!d) return;

        const displayStart = Math.min(state.dragStartIdx, state.dragEndIdx);
        const displayEnd = Math.max(state.dragStartIdx, state.dragEndIdx) + 1; 
        
        const currentContent = d.content;
        const newItems = getAdjustedCorrections(currentContent);

        const originalText = currentContent.substring(displayStart, displayEnd);
        newItems.push({ 
            id: crypto.randomUUID(),
            start: displayStart, 
            end: displayEnd, 
            comment: text,
            originalText: originalText,
            status: 'active'
        });

        // 状態更新
        state.correctionData = {
            baseText: currentContent,
            items: newItems
        };
        
        // 画面更新
        const modal = bootstrap.Modal.getInstance(document.getElementById('correctionModal'));
        if (modal) modal.hide();
        renderTeacherApp(); 
        
        const Toast = Swal.mixin({ toast: true, position: 'top-end', showConfirmButton: false, timer: 2000 });
        Toast.fire({ icon: 'success', title: '添削を保存しました' });

        // バックグラウンド送信
        const data = {
            id: d.id,
            title: d.title,
            class: d.class,
            name: d.name,
            content: d.content,
            correction: JSON.stringify(state.correctionData),
            status: d.status
        };

        runGAS('saveOrSubmitDraft', data, true).catch(e => {
             Swal.fire({ title: '通信エラー', text: '保存できませんでした', icon: 'error', heightAuto: false });
        });
    });

    // 楽観的保存: ステータス更新
    const submitTeacherEvaluation = (newStatus) => {
        const d = state.selectedStudentData;
        if (!d) return;
        
        // 即時反映ロジック
        // 1. 現在のリストデータを更新
        const currentIdx = state.selectedIndex;
        state.draftsList[currentIdx].status = newStatus;
        if (state.correctionData.baseText !== d.content) {
             const newItems = getAdjustedCorrections(d.content);
             state.correctionData = { baseText: d.content, items: newItems };
        }
        state.draftsList[currentIdx].correction = JSON.stringify(state.correctionData);
        
        if (newStatus === 'completed') state.checkedIds.add(d.id);
        
        const data = {
            id: d.id, title: d.title, class: d.class, name: d.name, content: d.content,
            correction: JSON.stringify(state.correctionData), status: newStatus
        };

        // 2. 次の児童へ進む (楽観的遷移)
        // フィルタリング後のリストで次を探すのがUX的に正しいが、
        // 実装が複雑になるため、単純にIDリストの次へ進む
        const nextIdx = currentIdx + 1;
        if (nextIdx < state.draftsList.length) {
            selectTeacherListItem(nextIdx);
            const nextEl = ui.teacherList.children[nextIdx]; // これはフィルタ後のDOMなのでズレる可能性あり
            // 正しくはDOMから探すべきだが、一旦これで。
            // DOM更新
            renderTeacherList(); 
        } else {
            // 最後まで行ったらリスト更新
            renderTeacherList(); 
            Swal.fire({ title: '完了', text: '全てのリストを確認しました', icon: 'success', heightAuto: false });
        }
        
        // 3. バックグラウンド送信
        runGAS('saveOrSubmitDraft', data, true).catch(e => {
             Swal.fire({ title: '通信エラー', text: '保存できませんでした', icon: 'error', heightAuto: false });
        });
    };

    ui.btnRework.onclick = () => submitTeacherEvaluation('rework');
    ui.btnComplete.onclick = () => submitTeacherEvaluation('completed');

    document.getElementById('btn-refresh-list').addEventListener('click', async () => {
        if(!state.teacherPassword) return;
        setLoading(true);
        try {
            const res = await runGAS('getDraftList', 'teacher', state.teacherPassword);
            setLoading(false);
            if(res.status==='success') {
                state.draftsList = res.data;
                state.selectedIndex = -1; state.selectedStudentData = null;
                ui.teacherGrid.innerHTML = '';
                ui.previewInfo.innerHTML = 'リストから選択してください';
                renderTeacherList();
                renderTeacherApp(); 
            }
        } catch(e) { setLoading(false); }
    });

    // --- Print Logic ---
    const executePrint = (docs) => {
        ui.printArea.innerHTML = '';
        const chars = state.charsPerLine;
        const linesPerPage = chars === 20 ? 20 : 16;
        const halfLines = linesPerPage / 2;
        const fontSize = chars === 20 ? '16pt' : '20pt';

        docs.forEach(doc => {
            const header = generateHeaderLines(doc.title, doc.class, doc.name, chars);
            const body = parseBodyWithIndex(doc.content, chars);
            const all = [...header, ...body];
            const pages = Math.ceil(all.length / linesPerPage) || 1;

            for(let p=0; p<pages; p++) {
                const pageLines = all.slice(p*linesPerPage, (p+1)*linesPerPage);
                const pageDiv = document.createElement('div');
                pageDiv.className = 'print-page';
                const gridLayout = document.createElement('div');
                gridLayout.className = 'print-layout-grid';

                const rightGrid = document.createElement('div');
                rightGrid.className = 'print-half-grid right-side';
                for(let i=0; i < halfLines; i++) {
                    const lineData = pageLines[i] || [];
                    const lineDiv = document.createElement('div');
                    lineDiv.className = 'print-line';
                    for(let j=0; j<chars; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'print-cell';
                        cell.style.fontSize = fontSize;
                        cell.textContent = (lineData[j]||{}).c || '';
                        if(j===chars-1 && lineData.length > chars) { 
                            const h = document.createElement('div');
                            h.className = 'hanging-chars-print';
                            h.textContent = lineData.slice(chars).map(d=>d.c).join('');
                            cell.appendChild(h);
                        }
                        lineDiv.appendChild(cell);
                    }
                    rightGrid.appendChild(lineDiv);
                }

                const gyobiArea = document.createElement('div');
                gyobiArea.className = 'print-gyobi-area';
                gyobiArea.innerHTML = `<div class="gyobi-content"><div class="gyobi-mark"></div><div>${(doc.title||'').substring(0,8)}</div><div style="font-size:0.8em; margin-top:5mm;">${p+1}</div></div>`;

                const leftGrid = document.createElement('div');
                leftGrid.className = 'print-half-grid left-side';
                for(let i=halfLines; i < linesPerPage; i++) {
                    const lineData = pageLines[i] || [];
                    const lineDiv = document.createElement('div');
                    lineDiv.className = 'print-line';
                    for(let j=0; j<chars; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'print-cell';
                        cell.style.fontSize = fontSize;
                        cell.textContent = (lineData[j]||{}).c || '';
                        if(j===chars-1 && lineData.length > chars) {
                            const h = document.createElement('div');
                            h.className = 'hanging-chars-print';
                            h.textContent = lineData.slice(chars).map(d=>d.c).join('');
                            cell.appendChild(h);
                        }
                        lineDiv.appendChild(cell);
                    }
                    leftGrid.appendChild(lineDiv);
                }
                gridLayout.appendChild(leftGrid);
                gridLayout.appendChild(gyobiArea);
                gridLayout.appendChild(rightGrid);
                pageDiv.appendChild(gridLayout);
                ui.printArea.appendChild(pageDiv);
            }
        });
        setTimeout(() => window.print(), 500);
    };

    document.getElementById('btn-print').addEventListener('click', () => {
        executePrint([{ title: ui.title.value, class: ui.class.value, name: ui.name.value, content: ui.content.value }]);
    });

    document.getElementById('btn-bulk-print').addEventListener('click', () => {
        if (state.checkedIds.size === 0) return Swal.fire({ title: 'エラー', text: '印刷する作文を選んでください', icon: 'warning', heightAuto: false });
        const selectedDocs = state.draftsList.filter(d => state.checkedIds.has(d.id));
        executePrint(selectedDocs);
    });

    // --- Init ---
    restoreFromAutoSave();
    checkReturnedAssignments();
    updateEditorUI();
});
</script>
